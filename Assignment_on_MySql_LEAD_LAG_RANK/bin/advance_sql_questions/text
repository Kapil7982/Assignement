

Q.1 Write query to find the id of student, roll_no, name of department for every student which belong to any department

Answer)  SELECT s.id, s.roll_no, s.name, d.name AS department_name FROM student s JOIN department d ON s.dep_id = d.id;
    

Q.2 Write query to find all details for every student which belong to department ‘Computer Science’.

Answer)   SELECT * FROM student s JOIN department d ON s.dep_id = d.id WHERE d.name = 'Computer Science';


Q.3 Write query to find all details for every student such that the student may or may not belong to a department.

Answer)  SELECT * FROM student s LEFT JOIN department d ON s.dep_id = d.id;   


Q.4 Write query to find all details for every department such that the department may or may not have students.

Answer)   SELECT * FROM department d LEFT JOIN student s ON d.id = s.dep_id;


Q.5 What will the degree and cardinality of the result generated by applying the CROSS JOIN operation on student and department table.

Answer)  The cardinality of the resulting table will be equal to the product of the number of rows in the "student" table and the number of rows in the
         "department" table. Assuming the "student" table has five rows and the "department" table has four rows, the resulting table will have 5 x 4 =
          20 rows. Each row will contain a combination of a student and a department, resulting in all possible pairings of students and departments.
          

Q.6 Which of the following syntax is better and why?
(a) SELECT * FROM left table INNER JOIN Right table ON left-table.col-name = right-table.col-name;
(b) SELECT * FROM left table, Right table WHERE left-table.col-name = right-table.col-name;

Answer)  Both syntaxes are valid, the INNER JOIN syntax is preferred more because it is more explicit, readable, and flexible.


Q.7 Write a query to display name of all soldiers who has same colonel such that the result should contain only those soldiers who has colonel.

Answer) SELECT s1.sol_name, s2.sol_name as 'Colonel' FROM soldiers s1 INNER JOIN soldiers s2 ON s1.col_id = s2.sol_id WHERE s1.col_id IS NOT NULL




                       Questions on Subquery
               ----------------------------------
               
Q.1 Write a query to find name, gender and department of all employees whose salary is more than average salary of all employees.

Answer)   SELECT name, gender, department FROM employee WHERE salary > (SELECT AVG(salary) FROM employee);


Q.2 Write a query to display gender and sum of salary of all employees gender wise such that display only those genders whose sum of salary is 50% or more of total salaries of department development.

Answer)  SELECT gender, SUM(salary) as total_salary FROM employee WHERE department = 'development' GROUP BY gender HAVING SUM(salary) >= (SELECT 0.5 * SUM(salary) FROM employee WHERE department = 'development');


Q.3 Write a query to insert a new record in the employee table with following details.
    e_id: 7 name: Suhani gender: female department: finance d_o_j: 2013-05-02 salary: It should be 5000 less than then average salary of all employee.
    
Answer)  UPDATE employee SET e_id = '7', name = 'Suhani', gender = 'female', department = 'finance', d_o_j = '2013-05-02', salary = (SELECT new_salary FROM temp_avg_salary)
         WHERE e_id = (SELECT MAX(e_id) FROM employee);


Q.4 Write a query list all details of employees whose salary is same as the salary of any employee of finance department.

Answer)    SELECT * FROM employee WHERE salary IN (SELECT salary FROM employee WHERE department = 'finance');


Q.5 Write a query list all details of employees whose salary is more than the salary of any employee of development department.

Answer)  SELECT * FROM employee WHERE salary > (SELECT MAX(salary) FROM employee WHERE department = 'development');


Q.6 Write a query list all details of employees whose salary is less than the 1.2 times of salary of all employee of development department.

Answer)  SELECT * FROM employee WHERE salary < 1.2 * (SELECT MAX(salary) FROM employee WHERE department = 'development');


Q.7 Spot the error in the following queries (If any). Write “no error” in case the query is correct
(a) SELECT T.name , T.gender FROM (
SELECT name as emp_name, gender as sex FROM employee
) T
(b) SELECT * FROM employee WHERE salary > AVG(salary)
(c) SELECT round(Salary * 0.0001) FROM employee WHERE department IN (‘testing’, ‘marketing’);

Answer)  (a) The query is correct.
         (b) There is an error in the query. The AVG() function is an aggregate function and cannot be used directly in the WHERE clause. It can be 
             used in the HAVING clause instead.
             SELECT * FROM employee HAVING salary > AVG(salary);
         (c) The query is correct.
         
 
 
                            Questions on functions
                       ----------------------------------
                       
(a) Write a query to display name, gender, salary and remark for every employee such that the remark is computed as follow-
If salary < 20000 then “Economical”
If salary < 30000 then “Just above Economical”
If salary < 40000 then “just below Executive”
Else “Executive”

Answer)  SELECT name, gender, salary,
         CASE
         WHEN salary < 20000 THEN "Economical"
         WHEN salary < 30000 THEN "Just above Economical"
         WHEN salary < 40000 THEN "Just below Executive"
         ELSE "Executive"
         END as remark
         FROM employee;
         
         
(b) Write a query to display name, salary, department and status for every employee such that status will be computed as follow-
If d_o_j is before 2010-01-01 then ‘Veteran’
Else ‘Young’


Answer)  SELECT name, salary, department, 
		 CASE 
		 WHEN d_o_j < '2010-01-01' THEN 'Veteran'
		 ELSE 'Young'
		 END AS status
		 FROM employee;
		 
		 
(c) Write a query to print RANK of every employee such that the employee with highest salary will be ranked #1.

Answer)  SELECT name, salary, department, RANK() OVER (ORDER BY salary DESC) AS rank FROM employee;


(d) Write a query to print RANK of every employee department wise such that the employee with lowest salary will be ranked #1.

Answer)  SELECT department, name, salary, RANK() OVER (PARTITION BY department ORDER BY salary ASC) as dept_rank FROM employee;


(e) Write a query to print salary of every employee along with salary of next employee.

Answer)  SELECT e1.salary, e2.salary AS next_salary FROM employee e1 LEFT JOIN employee e2 ON e1.salary < e2.salary GROUP BY e1.salary HAVING MIN(e2.salary) IS NOT NULL;


(f) Write a query to print salary of every employee along with salary of previous employee.

Answer)  SELECT e1.salary, (SELECT salary FROM employee e2 WHERE e2.e_id < e1.e_id ORDER BY e2.e_id DESC LIMIT 1) AS prev_salary FROM employee e1 ORDER BY e1.e_id;




             


